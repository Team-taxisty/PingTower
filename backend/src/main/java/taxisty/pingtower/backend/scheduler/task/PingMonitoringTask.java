package taxisty.pingtower.backend.scheduler.task;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import taxisty.pingtower.backend.storage.model.CheckResult;
import taxisty.pingtower.backend.storage.model.MonitoredService;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * Implementation of simple ping monitoring checks.
 * Performs basic availability checks for URLs.
 */
@Component
public class PingMonitoringTask implements ScheduledTask {
    
    private static final Logger logger = LoggerFactory.getLogger(PingMonitoringTask.class);
    private static final int DEFAULT_TIMEOUT_SECONDS = 30;
    
    private final HttpClient httpClient;
    
    public PingMonitoringTask() {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS))
                .build();
    }
    
    @Override
    public CheckResult execute(MonitoredService service) {
        long startTime = System.currentTimeMillis();
        LocalDateTime checkTime = LocalDateTime.now();
        
        try {
            // Build HTTP request
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                    .uri(URI.create(service.url()))
                    .timeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS));
            
            // Simple GET request for ping
            requestBuilder.GET();
            
            // Add custom headers if any
            addCustomHeaders(requestBuilder, service.headers());
            
            HttpRequest request = requestBuilder.build();
            
            // Execute request
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            // For ping, success if status code is 2xx
            boolean isSuccessful = response.statusCode() >= 200 && response.statusCode() < 300;
            
            return new CheckResult(
                    null, // ID will be generated by storage
                    service.id(),
                    checkTime,
                    isSuccessful,
                    response.statusCode(),
                    responseTime,
                    null, // Don't store response body for ping
                    null,
                    false, // No SSL check for ping
                    null,
                    "ping-task"
            );
            
        } catch (Exception e) {
            long responseTime = System.currentTimeMillis() - startTime;
            
            logger.debug("Ping check failed for service {}: {}", service.name(), e.getMessage());
            
            return new CheckResult(
                    null,
                    service.id(),
                    checkTime,
                    false,
                    0,
                    responseTime,
                    null,
                    e.getMessage(),
                    false,
                    null,
                    "ping-task"
            );
        }
    }
    
    @Override
    public String getTaskType() {
        return TaskType.PING.getCode();
    }
    
    @Override
    public boolean canExecute(MonitoredService service) {
        String url = service.url();
        return url != null && (url.startsWith("http://") || url.startsWith("https://"));
    }
    
    private void addCustomHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null && !headers.isEmpty()) {
            headers.forEach(builder::header);
        }
        
        // Add default headers
        builder.header("User-Agent", "PingTower-Ping/1.0");
    }
}