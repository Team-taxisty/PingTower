package taxisty.pingtower.backend.scheduler.task;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import taxisty.pingtower.backend.storage.model.CheckResult;
import taxisty.pingtower.backend.storage.model.MonitoredService;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * Implementation of API endpoint monitoring with JSON/XML response validation.
 * Extends HTTP monitoring with content parsing and validation capabilities.
 */
@Component
public class ApiMonitoringTask implements ScheduledTask {
    
    private static final Logger logger = LoggerFactory.getLogger(ApiMonitoringTask.class);
    private static final int DEFAULT_TIMEOUT_SECONDS = 30;
    
    private final HttpClient httpClient;
    private final ObjectMapper objectMapper;
    
    public ApiMonitoringTask() {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS))
                .build();
        this.objectMapper = new ObjectMapper();
    }
    
    @Override
    public CheckResult execute(MonitoredService service) {
        long startTime = System.currentTimeMillis();
        LocalDateTime checkTime = LocalDateTime.now();
        
        try {
            // Build HTTP request
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                    .uri(URI.create(service.url()))
                    .timeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS));
            
            // Set HTTP method
            setHttpMethod(requestBuilder, service.httpMethod());
            
            // Add custom headers
            addCustomHeaders(requestBuilder, service.headers());
            
            HttpRequest request = requestBuilder.build();
            
            // Execute request
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            // Validate API response
            boolean isSuccessful = validateApiResponse(response, service);
            
            return new CheckResult(
                    null, // ID will be generated by storage
                    service.id(),
                    checkTime,
                    isSuccessful,
                    response.statusCode(),
                    responseTime,
                    truncateResponseBody(response.body()),
                    null,
                    false, // SSL check not performed here
                    null,
                    "api-task"
            );
            
        } catch (Exception e) {
            long responseTime = System.currentTimeMillis() - startTime;
            
            logger.debug("API check failed for service {}: {}", service.name(), e.getMessage());
            
            return new CheckResult(
                    null,
                    service.id(),
                    checkTime,
                    false,
                    0,
                    responseTime,
                    null,
                    e.getMessage(),
                    false,
                    null,
                    "api-task"
            );
        }
    }
    
    @Override
    public String getTaskType() {
        return TaskType.API_CHECK.getCode();
    }
    
    @Override
    public boolean canExecute(MonitoredService service) {
        String url = service.url();
        if (url == null) {
            return false;
        }
        
        // Check if URL suggests an API endpoint
        return url.contains("/api/") || 
               url.contains("/health") || 
               url.contains("/status") || 
               url.contains("/v1/") || 
               url.contains("/v2/") ||
               url.endsWith(".json") ||
               url.endsWith(".xml");
    }
    
    private void setHttpMethod(HttpRequest.Builder builder, String method) {
        if (method == null || method.isBlank()) {
            method = "GET";
        }
        
        switch (method.toUpperCase()) {
            case "GET" -> builder.GET();
            case "POST" -> builder.POST(HttpRequest.BodyPublishers.noBody());
            case "PUT" -> builder.PUT(HttpRequest.BodyPublishers.noBody());
            case "DELETE" -> builder.DELETE();
            case "HEAD" -> builder.method("HEAD", HttpRequest.BodyPublishers.noBody());
            default -> builder.GET();
        }
    }
    
    private void addCustomHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null && !headers.isEmpty()) {
            headers.forEach(builder::header);
        }
        
        // Add default headers for API calls
        builder.header("User-Agent", "PingTower-Monitor/1.0");
        builder.header("Accept", "application/json, application/xml, text/plain, */*");
    }
    
    private boolean validateApiResponse(HttpResponse<String> response, MonitoredService service) {
        // Check response code
        if (response.statusCode() < 200 || response.statusCode() >= 300) {
            return false;
        }
        
        String responseBody = response.body();
        if (responseBody == null || responseBody.trim().isEmpty()) {
            return false;
        }
        
        // Try to parse as JSON first
        if (isJsonResponse(response)) {
            return validateJsonResponse(responseBody, service);
        }
        
        // Fall back to basic content validation
        if (service.expectedContent() != null && !service.expectedContent().isBlank()) {
            return responseBody.contains(service.expectedContent());
        }
        
        return true;
    }
    
    private boolean isJsonResponse(HttpResponse<String> response) {
        String contentType = response.headers()
                .firstValue("content-type")
                .orElse("");
        
        return contentType.toLowerCase().contains("application/json") ||
               contentType.toLowerCase().contains("text/json");
    }
    
    private boolean validateJsonResponse(String responseBody, MonitoredService service) {
        try {
            JsonNode jsonNode = objectMapper.readTree(responseBody);
            
            // Basic validation - ensure it's valid JSON
            if (jsonNode == null) {
                return false;
            }
            
            // Check for expected content in JSON structure
            if (service.expectedContent() != null && !service.expectedContent().isBlank()) {
                return containsExpectedContent(jsonNode, service.expectedContent());
            }
            
            // For health check endpoints, look for common success indicators
            if (service.url().contains("/health") || service.url().contains("/status")) {
                return validateHealthCheckResponse(jsonNode);
            }
            
            return true;
            
        } catch (Exception e) {
            logger.debug("Failed to parse JSON response for service {}: {}", service.name(), e.getMessage());
            return false;
        }
    }
    
    private boolean containsExpectedContent(JsonNode jsonNode, String expectedContent) {
        String jsonString = jsonNode.toString();
        return jsonString.contains(expectedContent);
    }
    
    private boolean validateHealthCheckResponse(JsonNode jsonNode) {
        // Common patterns for health check responses
        if (jsonNode.has("status")) {
            String status = jsonNode.get("status").asText().toLowerCase();
            return "ok".equals(status) || "healthy".equals(status) || "up".equals(status);
        }
        
        if (jsonNode.has("health")) {
            String health = jsonNode.get("health").asText().toLowerCase();
            return "ok".equals(health) || "healthy".equals(health);
        }
        
        if (jsonNode.has("state")) {
            String state = jsonNode.get("state").asText().toLowerCase();
            return "running".equals(state) || "active".equals(state);
        }
        
        return true; // If no specific health indicators, assume valid JSON is success
    }
    
    private String truncateResponseBody(String responseBody) {
        if (responseBody == null) {
            return null;
        }
        
        // Limit response body storage to 2KB for API responses (might contain useful debug info)
        final int maxLength = 2048;
        if (responseBody.length() > maxLength) {
            return responseBody.substring(0, maxLength) + "... [truncated]";
        }
        
        return responseBody;
    }
}