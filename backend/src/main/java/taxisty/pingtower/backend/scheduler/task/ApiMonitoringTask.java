package taxisty.pingtower.backend.scheduler.task;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import taxisty.pingtower.backend.storage.model.CheckResult;
import taxisty.pingtower.backend.storage.model.MonitoredService;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * Implementation of API endpoint monitoring with JSON/XML response validation.
 * Extends HTTP monitoring with content parsing and validation capabilities.
 */
@Component
public class ApiMonitoringTask implements ScheduledTask {
    
    private static final Logger logger = LoggerFactory.getLogger(ApiMonitoringTask.class);
    private static final int DEFAULT_TIMEOUT_SECONDS = 30;
    
    private final HttpClient httpClient;
    
    public ApiMonitoringTask() {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS))
                .build();
    }
    
    @Override
    public CheckResult execute(MonitoredService service) {
        long startTime = System.currentTimeMillis();
        LocalDateTime checkTime = LocalDateTime.now();
        
        try {
            // Build HTTP request
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                    .uri(buildUri(service))
                    .timeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS));
            
            // Set HTTP method with body if needed
            setHttpMethod(requestBuilder, service.httpMethod(), service.requestBody());
            
            // Add custom headers
            addCustomHeaders(requestBuilder, service.headers());
            
            HttpRequest request = requestBuilder.build();
            
            // Execute request
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            // Validate API response
            boolean isSuccessful = validateApiResponse(response, service);
            
            return new CheckResult(
                    null, // ID will be generated by storage
                    service.id(),
                    checkTime,
                    isSuccessful,
                    response.statusCode(),
                    responseTime,
                    truncateResponseBody(response.body()),
                    null,
                    false, // SSL check not performed here
                    null,
                    "api-task"
            );
            
        } catch (Exception e) {
            long responseTime = System.currentTimeMillis() - startTime;
            
            logger.debug("API check failed for service {}: {}", service.name(), e.getMessage());
            
            return new CheckResult(
                    null,
                    service.id(),
                    checkTime,
                    false,
                    0,
                    responseTime,
                    null,
                    e.getMessage(),
                    false,
                    null,
                    "api-task"
            );
        }
    }
    
    @Override
    public String getTaskType() {
        return TaskType.API.getCode();
    }
    
    @Override
    public boolean canExecute(MonitoredService service) {
        String url = service.url();
        return url != null && (url.startsWith("http://") || url.startsWith("https://"));
    }
    
    private void setHttpMethod(HttpRequest.Builder builder, String method, String requestBody) {
        if (method == null || method.isBlank()) {
            method = "GET";
        }
        
        switch (method.toUpperCase()) {
            case "GET" -> builder.GET();
            case "POST" -> {
                if (requestBody != null && !requestBody.isBlank()) {
                    builder.POST(HttpRequest.BodyPublishers.ofString(requestBody));
                } else {
                    builder.POST(HttpRequest.BodyPublishers.noBody());
                }
            }
            case "PUT" -> {
                if (requestBody != null && !requestBody.isBlank()) {
                    builder.PUT(HttpRequest.BodyPublishers.ofString(requestBody));
                } else {
                    builder.PUT(HttpRequest.BodyPublishers.noBody());
                }
            }
            case "DELETE" -> builder.DELETE();
            case "HEAD" -> builder.method("HEAD", HttpRequest.BodyPublishers.noBody());
            default -> builder.GET();
        }
    }
    
    private void addCustomHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null && !headers.isEmpty()) {
            headers.forEach(builder::header);
        }
        
        // Add default headers for API calls
        builder.header("User-Agent", "PingTower-Monitor/1.0");
        builder.header("Accept", "application/json, application/xml, text/plain, */*");
        builder.header("Content-Type", "application/json");
    }
    
    private URI buildUri(MonitoredService service) {
        try {
            String url = service.url();
            Map<String, String> queryParams = service.queryParams();
            
            if (queryParams == null || queryParams.isEmpty()) {
                return URI.create(url);
            }
            
            // Build query string
            StringBuilder queryString = new StringBuilder();
            for (Map.Entry<String, String> entry : queryParams.entrySet()) {
                if (queryString.length() > 0) {
                    queryString.append("&");
                }
                queryString.append(java.net.URLEncoder.encode(entry.getKey(), "UTF-8"))
                          .append("=")
                          .append(java.net.URLEncoder.encode(entry.getValue(), "UTF-8"));
            }
            
            // Append query to URL
            String separator = url.contains("?") ? "&" : "?";
            return URI.create(url + separator + queryString.toString());
            
        } catch (Exception e) {
            logger.warn("Failed to build URI with query params for service {}: {}", service.name(), e.getMessage());
            return URI.create(service.url());
        }
    }
    
    private boolean validateApiResponse(HttpResponse<String> response, MonitoredService service) {
        // Check expected status code
        if (service.getExpectedStatusCode() != null) {
            if (response.statusCode() != service.getExpectedStatusCode()) {
                return false;
            }
        } else {
            // Default: accept any 2xx status code
            if (response.statusCode() < 200 || response.statusCode() >= 300) {
                return false;
            }
        }
        
        // Check expected response body
        if (service.getExpectedResponseBody() != null && !service.getExpectedResponseBody().isBlank()) {
            String responseBody = response.body();
            if (responseBody == null || !responseBody.trim().equals(service.getExpectedResponseBody().trim())) {
                return false;
            }
        }
        
        return true;
    }
    
    private String truncateResponseBody(String responseBody) {
        if (responseBody == null) {
            return null;
        }
        
        // Limit response body storage to 2KB for API responses (might contain useful debug info)
        final int maxLength = 2048;
        if (responseBody.length() > maxLength) {
            return responseBody.substring(0, maxLength) + "... [truncated]";
        }
        
        return responseBody;
    }
}