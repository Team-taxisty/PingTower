package taxisty.pingtower.backend.scheduler.task;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import taxisty.pingtower.backend.storage.model.CheckResult;
import taxisty.pingtower.backend.storage.model.MonitoredService;

import javax.net.ssl.HttpsURLConnection;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Map;

/**
 * Implementation of HTTP/HTTPS monitoring checks.
 * Performs availability checks, response time measurement, and SSL certificate validation.
 */
@Component
public class HttpMonitoringTask implements ScheduledTask {
    
    private static final Logger logger = LoggerFactory.getLogger(HttpMonitoringTask.class);
    private static final int DEFAULT_TIMEOUT_SECONDS = 30;
    
    private final HttpClient httpClient;
    
    public HttpMonitoringTask() {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS))
                .build();
    }
    
    @Override
    public CheckResult execute(MonitoredService service) {
        long startTime = System.currentTimeMillis();
        LocalDateTime checkTime = LocalDateTime.now();
        
        try {
            // Build HTTP request
            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                    .uri(URI.create(service.url()))
                    .timeout(Duration.ofSeconds(DEFAULT_TIMEOUT_SECONDS));
            
            // Set HTTP method
            setHttpMethod(requestBuilder, service.httpMethod());
            
            // Add custom headers
            addCustomHeaders(requestBuilder, service.headers());
            
            HttpRequest request = requestBuilder.build();
            
            // Execute request
            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            long responseTime = System.currentTimeMillis() - startTime;
            
            // Validate response
            boolean isSuccessful = validateResponse(response, service);
            
            // Check SSL certificate if required
            LocalDateTime sslExpiryDate = null;
            boolean sslValid = true;
            
            if (service.sslCertificateCheck() && service.url().startsWith("https")) {
                SslCheckResult sslResult = checkSslCertificate(service.url());
                sslValid = sslResult.isValid();
                sslExpiryDate = sslResult.expiryDate();
            }
            
            return new CheckResult(
                    null, // ID will be generated by storage
                    service.id(),
                    checkTime,
                    isSuccessful && sslValid,
                    response.statusCode(),
                    responseTime,
                    truncateResponseBody(response.body()),
                    null,
                    sslValid,
                    sslExpiryDate,
                    "http-task"
            );
            
        } catch (Exception e) {
            long responseTime = System.currentTimeMillis() - startTime;
            
            logger.debug("HTTP check failed for service {}: {}", service.name(), e.getMessage());
            
            return new CheckResult(
                    null,
                    service.id(),
                    checkTime,
                    false,
                    0,
                    responseTime,
                    null,
                    e.getMessage(),
                    false,
                    null,
                    "http-task"
            );
        }
    }
    
    @Override
    public String getTaskType() {
        return TaskType.HTTP_CHECK.getCode();
    }
    
    @Override
    public boolean canExecute(MonitoredService service) {
        String url = service.url();
        return url != null && (url.startsWith("http://") || url.startsWith("https://"));
    }
    
    private void setHttpMethod(HttpRequest.Builder builder, String method) {
        if (method == null || method.isBlank()) {
            method = "GET";
        }
        
        switch (method.toUpperCase()) {
            case "GET" -> builder.GET();
            case "POST" -> builder.POST(HttpRequest.BodyPublishers.noBody());
            case "PUT" -> builder.PUT(HttpRequest.BodyPublishers.noBody());
            case "DELETE" -> builder.DELETE();
            case "HEAD" -> builder.method("HEAD", HttpRequest.BodyPublishers.noBody());
            default -> builder.GET();
        }
    }
    
    private void addCustomHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null && !headers.isEmpty()) {
            headers.forEach(builder::header);
        }
        
        // Add default headers if not present
        builder.header("User-Agent", "PingTower-Monitor/1.0");
    }
    
    private boolean validateResponse(HttpResponse<String> response, MonitoredService service) {
        // Check expected response code
        if (service.expectedResponseCode() != null && !service.expectedResponseCode().isBlank()) {
            try {
                int expectedCode = Integer.parseInt(service.expectedResponseCode());
                if (response.statusCode() != expectedCode) {
                    return false;
                }
            } catch (NumberFormatException e) {
                // If expected code is not a number, treat as pattern (e.g., "2xx")
                if (!matchesCodePattern(response.statusCode(), service.expectedResponseCode())) {
                    return false;
                }
            }
        } else {
            // Default: accept any 2xx status code
            if (response.statusCode() < 200 || response.statusCode() >= 300) {
                return false;
            }
        }
        
        // Check expected content
        if (service.expectedContent() != null && !service.expectedContent().isBlank()) {
            String responseBody = response.body();
            if (responseBody == null || !responseBody.contains(service.expectedContent())) {
                return false;
            }
        }
        
        return true;
    }
    
    private boolean matchesCodePattern(int statusCode, String pattern) {
        return switch (pattern.toLowerCase()) {
            case "1xx" -> statusCode >= 100 && statusCode < 200;
            case "2xx" -> statusCode >= 200 && statusCode < 300;
            case "3xx" -> statusCode >= 300 && statusCode < 400;
            case "4xx" -> statusCode >= 400 && statusCode < 500;
            case "5xx" -> statusCode >= 500 && statusCode < 600;
            default -> false;
        };
    }
    
    private SslCheckResult checkSslCertificate(String url) {
        try {
            HttpsURLConnection connection = (HttpsURLConnection) URI.create(url).toURL().openConnection();
            connection.setConnectTimeout(DEFAULT_TIMEOUT_SECONDS * 1000);
            connection.setReadTimeout(DEFAULT_TIMEOUT_SECONDS * 1000);
            connection.connect();
            
            Certificate[] certificates = connection.getServerCertificates();
            if (certificates.length > 0 && certificates[0] instanceof X509Certificate cert) {
                LocalDateTime expiryDate = cert.getNotAfter().toInstant()
                        .atZone(ZoneId.systemDefault())
                        .toLocalDateTime();
                
                boolean isValid = cert.getNotAfter().after(new java.util.Date());
                
                connection.disconnect();
                return new SslCheckResult(isValid, expiryDate);
            }
            
            connection.disconnect();
            return new SslCheckResult(false, null);
            
        } catch (Exception e) {
            logger.debug("SSL certificate check failed for {}: {}", url, e.getMessage());
            return new SslCheckResult(false, null);
        }
    }
    
    private String truncateResponseBody(String responseBody) {
        if (responseBody == null) {
            return null;
        }
        
        // Limit response body storage to 1KB to prevent database bloat
        final int maxLength = 1024;
        if (responseBody.length() > maxLength) {
            return responseBody.substring(0, maxLength) + "... [truncated]";
        }
        
        return responseBody;
    }
    
    /**
     * Helper record for SSL certificate check results.
     */
    private record SslCheckResult(boolean isValid, LocalDateTime expiryDate) {}
}